/**
 * Created by DELL on 2018/10/23.
 *
 *
 * 数组：一种线性的数据结构，用一组连续的内存空间，来存储一组具有相同类型的数据。
 * 正是因为其空间连续和数据类型相同，使其可以随机访问，
 * 但也正是因为数组要求空间连续，使其进行插入和删除操作之后也要保证空间的连续性，这就是插入删除后，需要产生数据的移动。
 * 在数据移动时，移动数据的量，根据数组中数据是否有序有一定的关系，如果数组数据有序，要求插入和删除元素后仍然有序的话，
 * 那么移动的数据量就会受到插入和删除数据的位置影响，平均复杂度就是O(n)
 * 如果数据无序，就可以简单的让被插入位置的元素移动到数组最后即可，如果删除的话，可以让数组最后位置的元素移动到被删除位置，时间复杂度为O(1)
 *
 * 数组的访问为何都是从索引为0开始的？
 *  这是因为寻址方式决定的。当创建一个数组后，那么这个数组数据结构的起始地址和终止地址就定下来了，在利用索引随机访问数组中的元素时，首先要找到索引指定元素
 *  开始的地址，然后根据数组的类型确定该元素占用的空间大小，取出从该元素开始位置到该元素结束位置空间中的数据即可。
 *  数据开始位置：array_address,索引为i的元素开始位置：array_address + i*element_size,元素所在空间：array_address + i*element_size  —— array_address + (i+1)*element_size
 * 根据计算公式可以发现：公式成立的话要求：地址连续的，element_size是固定，也就是元素类型是相同的。而且为了公式简洁，公式中i=0表示获取第一个元素。所以当索引从零开始。除此之外，
 * 索引有偏移量的含义，第一个元素的位置就是偏移量为0的位置。
 * 偏移量：偏移是一个相对的概念，相对某个位置的偏移，这个位置就是数据结构的开始位置，某个元素的偏移量，就是这个元素开始位置，与数据结构开始位置之间的偏移量。
 * 只要知道数据结构地址开始位置，再知道某个元素的偏移量的话，就可以知道这个元素的开始位置了。
 *
 * arr[i]表示什么：按照字面意思来讲就是获取数组中索引为i的元素，但是按照其数据获取流程的话，就是获取地址空间在：array_address + i*element_size到array_address + (i+1)*element_size
 * 空间中的数据，然后转换称相应的数据类型。在越界的情况下，array_address + i*element_size就不是数组的地址空间了。
 * 在c语言中，因为对数组的越界不进行检查，即时越界了，如果按照相应的寻址方式，查找的地址空间的数据可以转换称相应的数据类型的话，程序依然可以执行，
 * 那么此时再将arr[i]看成数组中索引为i的元素就有点不合适了。
 * 由此可以看出arr[i]时根据数据的起始地址+偏移量访问内存空间中数据的一种方式，如果不额外对数据越界进行控制的话，那么负下标，越界下标都是可以使用的，
 * 因为无论何种类型下标都是没有差别的，都是计算出一个地址，并取出数据的过程而已。
 *
 *
 * 链表：
 *  哨兵模式：通常用来处理在循环过程中的这样一个问题：对于循环开始或者循环结束的边界需要进行特殊处理，导致在循环中，需要不断进行判断找出头和尾，然后进行特殊处理，
 *  这就导致循环中对头部元素和尾部元素处理逻辑不同，为了让循环体中的代码逻辑功能单一，通过采取一定的“措施”让特殊的头和尾不在特殊，或者让头和尾的处理提到循环的外部进行。
 *  哨兵模式可以提高程序的运行效率，但是降低了程序的可读性。
 *  哨兵能提高运行效率的原因在于：从直观角度来讲，同时做一件事事情速度肯定比同时做多个事情快，主要就在于上下文的切换上。而从cpu执行指令的角度来讲，减少循环中的if等判断，减少指令流水被打断的次数。让cpu一直做有效功，而不是将时间花费在不同指令间的切换上。
 *
 *  基于链表数据结构开发出来的程序在测试时，主要针对边界条件继续验证：
 *      1.链表为空时。
 *      2.链表中只有一个节点。
 *      3.链表中只有两个节点。
 *      4.把头节点和尾节点作为处理对象时。
 *  为了让代码更加的健壮，要能够对某些特殊的情况，或者异常情况，进行容错处理，比如错误提示等。
 *
 *栈：栈是一种操作受限的线性数据结构，只能在线性结构的一端进行插入和删除。实现先进后出的操作。可以基于数组或者链表进行实现。
 *队列：是一种操作受限的先行数据结构，只能在线性结构的一端插入，另一端删除，实现先进先出的操作，可以基于数组或者链表进行实现。
 *既然栈和队列操作受限的线性结构，为何不直接使用线性结构呢？
 *  因为线性表的暴露了太多的操作接口，操作上的确灵活自由，但使用时就会比较不可控，自然容易出错。而且有点杀鸡用牛刀的感觉。
 *  其实这是编程的一个原则问题，就是尽量减少一个类／模块／接口提供的功能，接口最小原则。
 *  同时从语义上来讲，特定的数据结构是对特定场景的抽象。更具有针对性。
 *
 *
 *查看jdk中ArrayBlockingQueue源码发现：方法设计的一个原则，“功能单一性”
 * enqueue表示的入队方法，在入队的时候，并没有判断队列是否为空，就是直接入队，同样出对方法dequeue方法，也是不管队列是否为空，就是直接出队，
 * 这是因为方法enqueue和dequeue，是被方法put和take调用的，put/take方法是控制逻辑，也即是是否满/是否空的判断，
 * 这样是控制逻辑和业务逻辑进行分离，是方法职责最小化，这样可以利用方法的复用。
 * 在设计方法时，这也是一个很好的考虑。
 *
 *
 *
 *
 *
 *
 */
package linnerstructer;