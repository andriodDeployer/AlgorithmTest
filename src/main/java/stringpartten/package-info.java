/**
 * Created by DELL on 2018/12/17.
 * 字符串匹配：
 *      主串：被匹配的字符串。
 *      模式串：进行匹配的字符串。
 *      字符串匹配：就是判断主串中是否存在和模式串相同的子串。
 *
 *      假定主串的长度为n，字串的长度为m,那么主串中有n-m+1个字串可以和模式串进行比较
 *      BF算法：Brute Force算法，是一种暴力匹配算法，也叫朴素匹配算法，
 *          BF的思想相对简单，从主串的首个位置开始取出长度为m的子串与模式串进行比较，如果子串和模式串不同的话，
 *          那么就从主串的第二个位置开始取出长度为m的子串与模式串进行比较，依次下去，如果主串中不存和模式串相同的子串的话，
 *          那么需要(n-m+1)个子串与模式串进行比较，总的比较次数为(n-m+1)*m，时间复杂度为O((n-m)*m)
 *      RK算法：Rabin-Karp算法，整个算法的整体思路和BF算法是一样的，或者说整个算法是在RK算法上进行了一定的优化，优化点为子串和模式串的比较，
 *          在BF算法中，模式串和子串比较的时间复杂度为O(m),在RK算法中模式串和子串比较的时间复杂度为O(1);
 *          RK算法的对子串和模式串的是否相同的判断，由比较逐个比较字符串中字符演变成比较子串hash值和模式串hash值。时间复杂度由O(m)变成了O(1).
 *          使用两者的hash值进行比较，来判断两个字符串是否相等，但是要注意hash冲突的情况，在使用hash值进行比较的过程中：
 *                          hash值不同，则可以证明模式串和子串不同，
 *                          hash值相同，却不能证明模式串和子串相同，需要两个字符串进行真正的比较，
 *           所以在RK算法中，如果hash冲突很严重的情况的，RK算法的性能将会退化，最终退化成BF算法。
 *          在RK中重点是如何快速计算子串和模式串的hash值，如果hash值的计算效率不够高的话，那么从整体角度而言，RK算法的效率并没有相对BF有所提高。
 *          RK中hash值的计算由多种方式：
 *              1.K进制转10进制：
 *                  如果模式串和主串的 字符集 中包含了k个字符，那么我就可以用K进制的一个数字来表示子串和模式串，将这个K进制数转换成的10进制数，表示子串或模式串的hash值。
 *                  而且相邻两个子串的K进制数值，存在一定的关系，可以进行相互推导。所以利用这种方式可以快速高效的计算出每个子串的的K进制值。
 *              2.加法求和：
 *                  获取模式串和主串中的 字符集 ，将字符集中的每个字符和一个数字进行映射，那么模式串和子串就映射成数字串，求出模式串的数字串的和和子串的数字串的和分别作为两者的
 *                  hash值。
 *          在RK算法中选择计算hash值方法时需要注意：尽量减少hash冲突。因为当hash冲突发生时，需要子串和模式串的真正比较。降低性能。
 *
 *          RK算法延伸：
 *
 *
 *
 *              bloomFilter：布隆过滤器主要用来判断一个元素是否在一个集合中，这是一种非常规的算法，有一定的随机性。所以会存在一定 “多报” 的错误。
 *              布隆过滤器支持：增加和判断是否存在操作，不支持修改和删除。
 *              主要思路是：
 *                  创建一个较大的bit数组，当需要将key添加到布隆过滤器时，首先将key经过一个hash函数计算，将计算出的值作为一个索引，并将数组中该索引位置置为1.
 *                  查询：当查询一个key时，同样将这个key进行相同的hash计算，计算结果作为索引，判断bit数组中该索引位置是否为1，如果为1，布隆过滤器判断key存在
 *                  否则判断为不存在。
 *
 *                  由于hash算法计算的hash值，会存在冲突，所以当布隆过滤器判断存在时，并不一定的存在，这就是 多报 的错误，如果布隆过滤器判断不存在，则说明一定不存在。
 *                  为了减少hash冲突的方法：
 *                      1.增加多个hash函数，计算多个hash值，当添加一个key时，将多个hash值都添加到bit数组中，查询时也要计算出多个hash值，当数组中指定的多个位置都为1是才算存在。
 *                      2.增加数组的长度。
 *
 *                   由于布隆过滤器不支持删除操作，数组中的置为1的位置会原来越多，那么冲突的几率也就越来越大，这也是布隆过滤器的一个不足之处。
 *                    需要注意的是，布隆过滤器中并不存在实际的数据，只存存放了是否存在的标记而已。
 *                   布隆过滤器的用途：
 *                      1.添加在缓存和数据库之间，过滤掉请求key不存在时的数据库访问。如果没有布隆过滤器，当缓存中不存在时，就需要访问数据库，但是如果数据库中也没有的话，那么此次数据库访问就是无效的，
 *                      添加了布隆过滤器后，如果布隆过滤器判断不存在时，就可以不用访问数据库了。起到的对不存在的过滤。减少了io操作。
 *
 *
 *                  如果key为整数，且分布相对均匀的话，可以使用更简单的bitSet数据结构，bitSet也是一个bit数组，当将一个整数添加到bitSet中时，以这个整数为索引，
 *                  将bit数组中的相应位置设置为1，判断一个key是否存在是，也只需要查看以这个key为索引的bit数组中的值是否为1即可，
 *                  bitSet是使用相对简短，限制性也较多，因为没有hash操作，所以key要求时整数，因为直接使用key的值作为索引，如果在少量key中存在某个key较大的话，会使bitset产生较大的空间浪费。
 *
 *
 *             BM算法：Boyer-Moore算法，是一种相对RK和BF来说更加高效的一种算法，高效主要体现在，当出现不匹配的情况时，BM算法滑动的距离相对较长，而不是RK和BF只滑动1个单位。
 *             那么BM算法每次滑动多少个单位呢？这个通常由两种方式来计算：坏字符和好后缀两种方法。
 *             坏字符：
 *                  在使用BM算法进行匹配时，是从后往前匹配的，当遇到主串和模式串中不匹配的字符时，假设此时主串中字符为a，模式串字符为b，那么定义主串中的a为坏字符，
 *                  此时b在模式串中的索引记为Si,然后从从模式串中从后往前查找是否存在还字符a，如果找到，那么模式串中第一次出现a的位置在模式串中的索引记为Xi.如果模式串中不存在a那么记Xi为-1；
 *
 *                  在使用坏字符方式时，当出现坏字符时，那么模式串就要向后滑动Si-Xi个单位。
 *                      在特殊情况下，如：主串为abbbbabbbb,而模式串为aaaaa，坏字符为b，Si为4，Xi为-1，那么向右滑动单位为5，刚好为模式串的长度(也是BM算法中滑动距离最长单位数)，
 *                      那么在这种情况下的字符串匹配的时间复杂度为O(m/n),m为主串的长度，n为模式串的长度。
 *
 *                      但是在这种情况下，坏字符反而不适用：如主串为baaabbaaab，模式串为aaaab，坏字符为主串中的首位b，Si为0，Xi为4，那么滑动的距离为-4，也就是向左滑动了4个单位。
 *                      对于这种情况，坏字符时不适用的，此时就需要使用好后缀方式。
 *
 *              好后缀：好后缀规则和坏字符规则的基本思路很相似，也是让主串和模式串从后往前进行比较，在主串中的这个子串和模式串不匹配的情况下：如果主串和模式串的在尾部(后缀)相同，那么相同的这一部分称为好后缀，
 *                      通常在存在好后缀的情况下，一定会存在坏字符，如果不存在坏字符的话，那么主串的这个子串和模式串就完全匹配了。也就不存在所谓的好后缀了，所以好后缀和坏字符是同时存在的。
 *                      如：主串为abcdcabcde，模式串为ffadc，那么此时好后缀为“dc”，坏字符为主串中的第一个c。如果利用好后缀规则的话，该如何移动呢？
 *                          1.如果在模式串中存在第二个和好后缀相同的子串(bc*)，那么就将模式串中(bc*)滑动到与主串中好后缀(bc)相同的位置，让两者对齐，然后在进行判断。类似坏字符的移动原理。
 *                          2.如果在模式串中不存在第二个和好后缀相同的子串，那么判断模式串中是否存在和好后缀的后缀子串相同的子串如果存在，找出模式串中最大的前缀子串，然后移动对齐的位置。
 *                          注：前缀子串，字符串abc的前缀子串为：a,ab。后缀子串：c,bc。
 *
 *              因为在好后缀存在的情况下一定存在坏字符，那么选择哪一种模式呢？
 *                  分别用两种方式，进行计算，采用滑动距离长的那一种模式进行滑动。
 *
 *           KMP算法
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
package stringpartten;