/**
 * Created by DELL on 2018/11/12.
 *
 *
 * 二叉树：
 *  每个节点最多有两个子节点的树，两个子节点分别称为左右子节点。
 * 满二叉树：叶子结点全在底层，除了叶子节点外每个节点都有左右两个子节点。
 * 完全二叉树：叶子结点在最底下的两层，且最后一层叶子结点都靠左排列，除了最后一层，其他层的节点个数要达到最大。
 * 根据定义可以看出，满二叉树是完全二叉树的一种特例。
 * 使用完全二叉树的意义在于，可以使用数组在占用最少空间的的情况下，存储树状结构。{@link tree.visittree.LevelVisit.TreeNode}，如果不是完全二叉树话，可能会存在空间的浪费。
 * 通常情况下，存储树状结构最多的情况是使用链表方式，相对于使用数组，链表需要存放指向左右子节点的引用。空间利用率没有数组高。
 *
 *
 * 二叉查找树：又称为二叉搜索树，主要就是为了快速查找的树状数据结构。二叉查找树要求，在树中任意节点上，
 *            其左子树中每个节点的值小于该节点的值，有子树中每个节点的值要大于这个节点的值。
 *          如果在不断的插入，删除数据的动态行为中，可能导致二叉搜索树退化成链表。
 *          为了避免而查找树退化成链表，要对二叉查找树进行平衡化操作。将其变成一个平衡二叉树。
 *      使用散列表进行插入，删除和查找操作的时间复杂度为为常量级别O(1),而二叉查找树在比较平衡的情况下，插入删除和查找操作的时间复杂度为O(logn)
 *      然而在很多情况下，二叉查找树比散列表的用途更广泛？主要有以下几个原因：
 *          1.散列表是无序存储的，如果要输出有序序列的话，散列表中的数据要先进行排序，才可以，而对于查找二叉树，只需要中序遍历即可。
 *          2.散列表扩容耗时很多，而且当遇到散列冲突时，性能不稳定，尽管二叉查找树有时候性能不稳定(退化成链表)，但是在工程中，我们最常用的时平衡二叉树，可以时时间复杂度稳定在O(logn)
 *          3.虽然散列表的时间复杂度为常数，但是这个常数有可能会大于O(logn),而且加上散列函数的耗时，也不一定比平衡二叉查找树效率高。
 *          4.散列表构造相对二叉查找树要复杂，要考虑的因素也很多，如散列函数设计，冲突解决办法，扩容等
 *          综合以上几点，平衡的二叉查找树的性能在某些情况下，要优于散列表。
 *
 * 平衡二叉树：平衡二叉树严格来讲是这样的：二叉树中任意一个节点的左右子树的高度相差不能大于1。
 * 平衡二叉查找树在满足平衡二叉树的基础上，还要满足二叉查找树(任意节点左子树中的每个节点值，小于这个节点，右子树中每个节点的值大于这个节点)。
 *  AVL是最早发明的平衡二叉查找树，AVL严格满足平衡二叉树的定义。
 *  然而在工程中，并不一定要求平衡二叉树一定要严格满足定义。因为定义平衡主要就是防止二叉查找树时间复杂度严重退化的问题，平衡的目的是让整棵树左右看起来比较对称，不要出现左子树很高右子树很矮的情况。
 *  只要左右子树高度差别不是很大的话，如二叉树的高度仍然是log2n(查找的时间复杂度)数量级的话。也可以看成一个合格的平衡二叉树。
 *  平衡可以理解成：性能不退化。近似平衡可以理解成：性能不会退化太严重。
 *
 *
 *  红黑树：红黑树严格来说不是平衡二叉树，但是从工程角度来说，满足平衡二叉树的要求。
 *  红黑树产生的原因：普通的查找树容易产生性能严重退化的情况，如果使用严格意义上的平衡二叉树的话，虽然能保证查找，删除等操作的性能，但是维护的成本太高，因为每次进行插入删除，都要对树进行调整，
 *  让其一直出于平衡状态。而红黑树没有严格平衡二叉树的性能，但是同样也没有那么高的维护成本,主要就是其数据结构红黑节点定义，保证在动态的新增删除的情况下不需要太多的调整，就能保证近似的平衡。
 *  它是一种近似平衡树，而且性能十分的稳定，时间复杂度稳定在O(logn).
 *
 *
 *
 *
 *
 *
 */
package tree;