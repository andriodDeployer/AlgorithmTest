/**
 * Created by DELL on 2018/11/5.
 *
 *  关于排序优劣的评判指标：
 *      1.内存消耗：排序需要另外开辟内存空间。如果在原来的数据上进行排序的话，也就是空间复杂度位O(1),成为原地排序。
 *      2.稳定性：如果待排序的序列中存在值相同的元素，经过排序后，相等元素之间原有先后顺序是否方式变化，如果没有发生变化，就是稳定的，否则就是不稳定的。
 *      3.时间复杂度：当多个算法的时间复杂度相同时，要尽量比较他们的系数，常数等。
 *
 *
 *      排序算法的稳定性有什么作用：
 *          对于二次排序可以利用排序的稳定性来实现。需求：先按照指标A进行排序，如果A相同的话，在按照指标B进行排序。
 *          实现方式：先按照指标B对全部数据进行排序，按照使用稳定性排序算法按照指标A对全部数据进行排序。即可。
 *
 *      在冒泡/选择/插入排序中，冒泡和插入排序在优化的情况下，时间复杂度相当，都比选择要好，而且两者都是稳定的，选择则是不稳定的，
 *      如果在冒泡和插入排序中进行选择的话，插入排序在实现上更简单一些，时间复杂度的系数更小，效率更高。
 *
 *
 *      归并排序的时间复杂度和快速排序的时间复杂度是一样的，但是通常情况下，会选择快速排序，因为相比与归并排序，快速排序是稳定的，
 *
 *
 *      问题:
 *          对于在O(n)时间内，取出第K大的元素,是否可以利用冒泡,选择排序(这两种排序每一遍排序后，会确定一个最值)？
 *              因为这两种排序虽然时间复杂度时O(n^2),因为从中选出第k大元素，只需要执行k遍循环即可，所以使时间复杂度为O(kn)，也就是O(n)?
 *              这种想法前半段是可以的，但是有时间复杂度是O(kn),得不出时间复杂度为O(n)，为k不是常数。所以不能省略。
 *           关于算法实现参照 {@link sort.Kth}
 *
 *
 *      线性排序：
 *          排序算法得时间复杂度是线性的，也就是时间复杂度为O(n)。时间复杂度比较低，但是对数据本身要求比较高，所以这类排序，适用范围并不广泛。
 *
 *
 *      如何实现一个通用性高，性能也很高的排序算法呢？
 *          通常在我们使用的类库中都提供了排序算法的实现，如java的Collection.sort，C++中的stable_sort等，其中java的排序采用的堆排序，
 *          而c和c++提供的排序实现是快速排序。
 *
 *          我们知道虽然归并排序时间复杂度《=快速排序的时间复杂度，但是由于归并排序需要额外的存储空间导致，其使用范围并不广泛。
 *          但是当需要排序的数据量不大，或者系统内存充足的情况下，可以使用归并排序，达到空间换时间的目的。
 *
 *          对于使用比较多的快速排序，在有些特殊情况下，如果选取中间点pivot不合适的话，会导致其时间复杂度退化成O(n^2)。
 *          那么如何对快速排序进行优化的？
 *              1.优化pivot的选取：从给定序列中随机选取一个数。根据概率来讲，出现最坏情况的概率很小。
 *              2.由于快速排序是递归实现的，所以从优化递归方面下手。
 *              3.当快速排序的数据规模/区间小于等于4是，将原来的快速排序替换成插入排序，因为当数据量规模小的时候，O(n^2)并不一定比O(nlog(n))大。
 *              因为时间复杂度并不一定能够代表程序的执行时间，只是代表了，时间增长的趋势，而不是时间的真实值，因为我们说的时间复杂度，仅仅是最高阶的那一项，
 *              省略了常数项，低阶项，系数等，所以当数据规模不大的时候，o(n^2)比一定比O(nlogn)大。
 *              3.哨兵模式，其实就是提高cpu流水线执行，防止打断的一种优化。
 *
 *
 *
 *
 *
 */
package sort;